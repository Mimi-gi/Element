# Element仕様書

## 概要
いろんなものに乗り移っていく2Dパズルプラットフォーマー

### メインギミック 乗り移り
プレイヤーの本体が目であるようにユーザーからは見えている
乗り移れるオブジェクトとそうでないものがある
「フォーカスモード」で乗り移れるオブジェクトを見れ、そこから何らかの入力で一番ちかいオブジェクトに乗り移る(後述)
乗り移り可能なオブジェクトは、そのオブジェクトが完全にカメラから見えている事(後述)
オブジェクトにはいろんなギミック・能力がある(ジャンプ可能、移動可能、浮遊可能だったり、ボタンを押せる、ものを動かせるなど様々)

### 現状考えている仕様
#### 乗り移り周りの処理
- 乗り移れるオブジェクトにはIPossableを継承させる。
    - IPossableには、
        - void Possess()
        - int Layer 
        - bool IsPossess
        - void Act()
        をとりあえず用意

Actは入力により呼ばれる
Actが呼ばれた時に、最適なIPossableなオブジェクト(後述)のPossess()を呼ぶ(乗り移り)
乗り移りが成功したら、古いオブジェクトのIsPossessをfalseに、新しいもののをtrueにする。
IsPossessがtrueのものしか動かすことはできない
(ひとつの目に対して1オブジェクトPossessできるようにしたりとかの可能性はある。目は二つなので、つまり二つのオブジェクトを操れるかもしれない)

#### 最適なIPossable
フォーカスした際のオブジェクトの表示方法には3段階ある
1. そもそも何も表示されない(フォーカス外)
2. 乗り移れることはスプライトなどで提示されるが、乗り移ることはできない(最適なIPossableでない)
3. 乗り移れる(最適なIPossable)(これもスプライトなどで提示。エフェクトにするかも)

選定方法は、「オブジェクトのコアが見える」∧「プレイヤーのコアに一番近い」こと。(これってVisibleで判定できるんだろうか。例えば透明度が0のオブジェクトに完全に覆われているオブジェクトはVisibleなんだろうか。無理なら自作でアルゴリズムかなんかを組む必要がある)

### 解答
1. フォーカスモードはボタン長押し。フォーカス中のゲーム時間は倍率をかけて遅くしたい。フォーカス中は入力を受け付けない。解除はボタンが離されたら
2. 何らかの入力は何らかの入力。まだ決まってない。InputSystemから制御する。乗り移り可能オブジェクトから最適なものを選ぶ方法はIPossableの部分に書いてある。
3. オブジェクトのコアの位置がカメラから見えていれば良い。他のスプライトにかぶさってたらダメ。コアのサイズは小さくするから部分的に見えてる問題は発生しないと思うけど、もし発生したら完全に見えるようにする。
4. コアの定義は未定だけど、子オブジェクトにしたい。
5. Layerは、明示的にオブジェクトたちの順序をこちらで指定するためのもの。スプライトのレイヤーとは極力分けて考える。(基本的には連携をさせる)
6. Act()の入力も未定義。InputSystemで制御するから具体的にはまだ考えなくていい。固有のアクションは固有にメソッドを持たせる。憑依周りだけAct()に任せる(命名を変えたほうが良い)
7. 乗り移り後はもともとの状態に戻る。位置はそのまま。マリオオデッセイのキャプチャにかなり挙動は近い。ゲーム的には基本無機物に憑依する。
8. 複数オブジェクトに関しては、「二つに分かれる事の出来るPossable」というのを用意する。これを以下「IDoublable」と呼ぶ。「IDoublable→IPossable」に関しては、二つに分かれたそれぞれでフォーカス領域を持っていることにして、「IPossable→IDoublable」に関しては、Doublableのどちらにもコアを存在させ、両方に乗り移れるようにする。
9. 失敗・ゲームオーバーはIPossableにDeath()関数を用意して、条件が満たされたらそれを呼ぶという形にする。憑依中以外のIPossableもDeath()を呼ばれうる。
10. クールダウンなどは一切ない。が、乗り移りなどのアニメーション中はゲーム自体を止めたり(勝手に落ちたりしない)、何かしらのイベントの際にゲーム自体を止める機能は何かに持たせたい。SOLIDに反しているが、gameManagerのようなものを作ったほうが良いのかもしれない。
11. カメラは基本ステージごとに固定。メトロイドヴァニアの様に一つのマップを移動するのでステージの境界部分になんかしらの判定をつけてカメラを動かす機構が必要
12. これは未定だからしゃーない。とりあえず「この台が邪魔だから動かしてどかす」とかそういう機構はある。
12. 探索型。メトロイドヴァニアっぽい

### 解答2
1. Act()はTryPossess()に変更する。
2. GameStateManagerが丸いかなぁ
3. カメラ移動中はプレイヤー操作不可
4. そうするつもり
5. はい。難しいのでいくつか方法を提示してほしい
6. InputSystemを使うからあなたはキーバインドを知っている必要がない

---

## システム設計

### IPossableインターフェース（確定）
すべての乗り移り可能なオブジェクトが実装するインターフェース。

**定義されたメンバー**：
- `void TryPossess()` - 乗り移り入力通知（旧Act()）
- `int Layer { get; }` - オブジェクトの描画順序（独自レイヤーシステム）
- `bool IsPossess { get; set; }` - 現在乗り移られているか
- `Transform Core { get; }` - オブジェクトのコア（視認性・距離判定用の子オブジェクト）
- `void Death()` - 死亡処理

### IDoublableインターフェース（確定）
二つに分かれることができるオブジェクトのインターフェース。IPossableを継承。

**定義されたメンバー**：
- `bool IsSplit { get; }` - 現在分離状態か
- `void Split()` - オブジェクトを二つに分離
- `void Merge()` - 分離したオブジェクトを統合
- `IPossable GetOtherHalf()` - もう一方のIPossableを取得

### DarkとDarkSource（確定）
- **Dark**: プレイヤーの本体（目）。デフォルトのIPossable。死亡時にリスポーンする先。
- **DarkSource**: リスポーン地点。ステージごとに配置可能。複数存在可能。

**Darkのライフサイクル**：
- Darkも死ぬことがある
- 死んだらDarkSourceの位置に新しいDarkを生成してリスポーン
- 他のIPossableに乗り移ったら、古いDarkは自動で破棄される
- Darkは常にシーンに存在するわけではない

### マネージャー構造（確定）
ゲームシステムを以下のマネージャーで責務分離：

#### 1. PossessionManager
**責務**: 乗り移りシステム全体の管理
- 現在Possess中のIPossableの追跡
- 乗り移り処理の実行（`PossessTo()`）
- フォーカスモード中の最適なターゲット選定（「コアが見える」∧「最も近い」）
- 死亡時のリスポーン処理（Darkの生成・破棄）

#### 2. TimeManager
**責務**: 時間倍率の制御
- `Time.timeScale`の管理
- フォーカスモード中の減速（倍率指定可能）
- イベント/アニメーション中の停止
- ゲーム全体の時間状態管理

#### 3. StageManager
**責務**: ステージ/エリア管理
- 現在アクティブな`DarkSource`の管理
- カメラエリア境界の管理
- ステージ間の遷移処理
- エリアごとの設定（BGM、環境など）

#### 4. CameraController
**責務**: カメラ制御
- カメラの位置・サイズの制御（LitMotion使用）
- エリア境界でのカメラ遷移
- プレイヤー追従ロジック

#### 5. InputProcessor
**責務**: 入力の一元管理
- InputSystemからの入力受付
- 入力イベントの配信（ReactiveProperty等）
- 入力の有効/無効制御

#### 6. GameStateManager
**責務**: ゲーム状態の統括
- ゲーム全体の状態管理（Playing, Paused, FocusMode, Transition, Menu, GameOver等）
- 状態遷移のロジック
- 他のマネージャーへの状態変化通知

**マネージャー間の依存関係**：
```
GameStateManager (全体の司令塔)
    ↓
├── TimeManager (時間制御)
├── InputProcessor (入力)
│       ↓
├── PossessionManager (乗り移り)
│       ↓
└── StageManager (ステージ/エリア)
        ↓
    CameraController (カメラ)
```

### コア視認性判定（検討中）
スプライトの重なりを考慮したコアの視認性判定。以下の方法を検討：
1. **Physics Raycast**: カメラからコアへRaycastを飛ばして遮蔽物チェック（プロトタイプ推奨）
2. **SortingLayer/OrderInLayer**: 描画順序を使った判定（視覚的に正確）
3. **カスタムレイヤーシステム**: IPossable.Layerを活用した独自判定（制御しやすい、本番推奨）

実装優先度: プロトタイプはRaycast → 正式版はカスタムレイヤー

